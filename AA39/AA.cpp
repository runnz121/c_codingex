// a = 1 3 5		
// b = 2 3 6 7 9

// c = 1 2 3 3 5	//처음에 a,b 배열의 0번 인덱스 값중 작은값을 넣음, 그리고 넣은 배열의 해당하는 인덱스 값을 증가시킴 
// 					//그리고 그 증가된 배열의 인덱스값을 넣지 않은 배열의 첫번째 값과 비교 (즉 넣은 배열의(a)의 인덱스는 i -> i+1이 되고 이를 b배열의 i와 비교하라는 뜻)
//					//이렇게 반복하여 a,b둘중 하나의 배열이 모두 c배열에 넣어지면 반복문을 종료시키고 넣어지지 않은 배열의 원소값들을 그 순서대로 c배열에 넣는다   

#include <stdio.h>
#include <vector>
#include <algorithm>

using namespace std;
int a[101], b[101], c[201]; 

int main() {
	freopen("input.txt", "rt", stdin);
	
	int n, m, i, p1=1, p2=1, p3=1;
	
	scanf("%d", &n);	
	for(i=1; i<=n; i++){
		scanf("%d", &a[i]);
	}
	
	scanf("%d", &m);
	for(i=1; i<=m; i++){
		scanf("%d", &b[i]);
	}
	
	while(p1<=n && p2<=m){				// 두 배열의 원소가 c배열에 아직도 들어갈 것이 남아 있는 경우  
		if(a[p1]<b[p2]){				// a, b배열의 값을 비교해서 a가 작은 경우  
			c[p3++]=a[p1++];			// c배열에 a배열값을 넣고나서 p3 와 p1을 증가 시킨다  c[p3++]=a[p1++] -> 대입연산자 = 후에 증가 시킨다  
		}
		else{
			c[p3++]=b[p2++];			// 위와 반대로 b가 더 작은 경우  
		}
		
	}
	
	while(p1<=n)						//a배열의 원소가 남은 상태에서 끝난 경우  
	{
		c[p3++]=a[p1++];				//a배열의 원소를 모두 c배열에 넣는다  
	}
		
	while(p2<=m)						//b배열의 원소가 남은 경우  
	{
		c[p3++]=b[p2++];
	}
	
	for(i=1; i<p3; i++){				//p3 는 넣고 증가임으로 마지막 원소 그 다음것을 가르키고 있기 때문에 그 전까지 돌림  
		printf("%d ", c[i]);
	}

	
	return 0;
}
